// ext/syscore/syscore.c

// Include Ruby
#include <ruby.h>

// Core function libraries
#include <cpufreq.h>
#include <cpuinfo.h>
#include <proc/procps.h>
#include <proc/readproc.h>
#include <proc/sysinfo.h>
#include <sys/utsname.h>
#include <unistd.h>

// C++ includes
#include <cstdio>
#include <fstream>
#include <iostream>
#include <string>

// Local includes
//#include ""

// Defines
#define MAXSTR 255
#define HOSTSTR char name[MAXSTR]
#define PROC_FILE "/proc/stat"
#define CPUI_INIT if (!method_syscore_cpuinfo_init()) { abort(); }

// Process table global -- NOT exposed/wrapped
PROCTAB *PTABLE = 0;

// cpuinfo holders
const cpuinfo_package *PACKAGES;
const cpuinfo_cluster *CLUSTERS;
const cpuinfo_core *CORES;
const cpuinfo_uarch_info *UARCHS;
const cpuinfo_processor *PROCESSORS;
const cpuinfo_cache *CACHES;

// Initializer block in C
extern "C" {
  // Core module and class data
  VALUE SysCore = Qnil;
  bool cpu_info_init = false;
  
  // Abstract reload the cpuinfo data
  void method_syscore_cpuinfo_load() {
    PACKAGES = cpuinfo_get_packages();
    CLUSTERS = cpuinfo_get_clusters();
    CORES = cpuinfo_get_cores();
    UARCHS = cpuinfo_get_uarchs();
    PROCESSORS = cpuinfo_get_processors();
  } // End abstract cpuinfo loader

  // Required initialization
  // Initialize the CPU info
  bool method_syscore_cpuinfo_init() {
    if (!cpu_info_init) {
      // Initialize the system.
      cpu_info_init = cpuinfo_initialize();
      
    }
    return cpu_info_init; // Return current state of the flag
  } // End CPU info init

  // Deinitialize the CPU info
  bool method_syscore_cpuinfo_deinit() {
    if (cpu_info_init) {
      // If the flag is initialized, run the cleanup
      cpuinfo_deinitialize();
      cpu_info_init = false; // Then set the flag to Ruby false
    }
    return cpu_info_init; // Return the flag
  } // End CPU info deinit
  // End required initialization
} // End initializer block

// C++ segment
namespace SysCorePlusPlus {
  // Typedef for what a logical core is
  typedef struct {
    int pindex; // Processor index
    
    // Processor use stat fields
    double user;
    double nice;
    double system;
    double idle;
    double iowait;
    double irq;
    double softirq;
    double steal;
    double guest;
    double guest_nice;
  } lcore_t; // End logical processor struct
  
  // Attach cache data to processor
  void u_method_syscore_map_cache(VALUE proc,
    const struct cpuinfo_processor *lc) {
    // Shorthand extract cache levels
    const struct cpuinfo_cache *l1i = lc->cache.l1i;
    const struct cpuinfo_cache *l1d = lc->cache.l1d;
    const struct cpuinfo_cache *l2 = lc->cache.l2;
    const struct cpuinfo_cache *l3 = lc->cache.l3;
    const struct cpuinfo_cache *l4 = lc->cache.l4;
  } // End cache attach
  
  // Attach physical core data to processor
  void u_method_syscore_map_pcore(VALUE proc,
    const struct cpuinfo_processor *lc) {
    // Shorthand extract the core object
    const struct cpuinfo_core* core = lc->core;
    
    // The relevant data from the core object are
    // the core ID (should not need the first logical
    // processor's index, as this ID is already unique and
    // comparable), vendor, micro-architecture, and frequency.
    rb_hash_aset(proc, ID2SYM(rb_intern("index_core")),
      INT2NUM(core->core_id));
    rb_hash_aset(proc, ID2SYM(rb_intern("frequency_core")),
      LONG2NUM(core->frequency));
    rb_hash_aset(proc, ID2SYM(rb_intern("vendor")),
      INT2NUM(core->vendor));
    rb_hash_aset(proc, ID2SYM(rb_intern("uarch")),
      INT2NUM(core->uarch));
  } // End physical core attach
  
  // Attach cluster data to processor
  void u_method_syscore_map_cluster(VALUE proc,
    const struct cpuinfo_processor *lc) {
    // Shorthand extract the cluster object
    const struct cpuinfo_cluster* cluster = lc->cluster;
    
    // The most-probably relevant cluster data are the index
    // of the cluster (same reason as core, for why the first
    // logical processor is not included) and the cluster frequency.
    // 
    // Vendor is not included, because
    // it refers to the vendor of "cores in this cluster", which
    // means it will already be the same as those in the core
    // data attachment.
    // 
    // The above is true with micro-arch -- uarch.
    // 
    // Despite a similar analog in the frequency, this field WILL
    // be included, in case the user wishes to access a cluster-wide
    // setting / average value for ALL cores in the cluster.
    rb_hash_aset(proc, ID2SYM(rb_intern("index_clus")),
      INT2NUM(cluster->cluster_id));
    rb_hash_aset(proc, ID2SYM(rb_intern("frequency_clus")),
      LONG2NUM(cluster->frequency));
  } // End cluster attach
  
  // Attach package data to processor
  void u_method_syscore_map_package(VALUE proc,
    const struct cpuinfo_processor *lc) {
    // Shorthand extract the package object
    const struct cpuinfo_package* pack = lc->package;
    
    // The only really relevant data is the package name (for
    // identification and display) and the index of the first
    // logical processor, for package combination sorting.
    rb_hash_aset(proc, ID2SYM(rb_intern("index_pkg")),
      INT2NUM(pack->processor_start));
    rb_hash_aset(proc,ID2SYM(rb_intern("name")),
      rb_str_new2(pack->name));
  } // End package attach

  // Read in a single logical processor and map it
  // Not exported, because takes non-Ruby values
  // Will return a raw hash to be wrapped Ruby-side
  VALUE u_method_syscore_map_lcore(lcore_t lcr) {
    // Check if library is init
    CPUI_INIT;
    
    // New CPU hash
    VALUE lch = rb_hash_new();
    
    rb_hash_aset(lch, ID2SYM(rb_intern("user")), DBL2NUM(lcr.user));
    rb_hash_aset(lch, ID2SYM(rb_intern("nice")), DBL2NUM(lcr.nice));
    rb_hash_aset(lch, ID2SYM(rb_intern("system")), DBL2NUM(lcr.system));
    rb_hash_aset(lch, ID2SYM(rb_intern("idle")), DBL2NUM(lcr.idle));
    rb_hash_aset(lch, ID2SYM(rb_intern("iowait")), DBL2NUM(lcr.iowait));
    rb_hash_aset(lch, ID2SYM(rb_intern("irq")), DBL2NUM(lcr.irq));
    rb_hash_aset(lch, ID2SYM(rb_intern("softirq")), DBL2NUM(lcr.softirq));
    rb_hash_aset(lch, ID2SYM(rb_intern("steal")), DBL2NUM(lcr.steal));
    rb_hash_aset(lch, ID2SYM(rb_intern("guest")), DBL2NUM(lcr.guest));
    rb_hash_aset(lch, ID2SYM(rb_intern("guest_nice")), DBL2NUM(lcr.guest_nice));
    
    // Indices for this processor, by core, cluster, package
    const struct cpuinfo_processor *lcptr = cpuinfo_get_processor(lcr.pindex);
    //u_method_syscore_map_cache(lch, lcptr); // Cache data
    // Physical core (the passed data is logical core, so this
    // attaches physical core info -- the numbers may not be the same)
    //u_method_syscore_map_pcore(lch, lcptr);
    //u_method_syscore_map_cluster(lch, lcptr); // Cluster
    //u_method_syscore_map_package(lch, lcptr); // Package / socket
    uint pkidx = PACKAGES[0].processor_start;
    std::cerr << "Package index?? " << pkidx << "\n";
    //rb_hash_aset(lch, ID2SYM(rb_intern("index_pkg")),
    //  UINT2NUM(123));
    
    // Return the mapped CPU hash
    return lch;
  } // End CPU logical core wrapper

  // Processor usage stat method
  VALUE method_syscore_proc_stat(VALUE self) {
    // Optimizations
    std::ios::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    
    // File
    std::ifstream fd;
    
    // Data components
    std::string sub, name;
    double user, nice, system, idle, iowait, irq, softirq,
      steal, guest, guest_nice;
    double total, avg;
    int pindex;
    
    // Logical processor core
    SysCorePlusPlus::lcore_t lc;
    
    // Counter
    int count = 0;
    
    // Create hash to hold the logical processors,
    // mapped to the package, with sister elements of
    // cluster and core data.
    VALUE packages = rb_hash_new();
    
    // Stream read loop
    fd.open(PROC_FILE);
    while (fd >> name >> lc.user >> lc.nice >> lc.system >> lc.idle
      >> lc.iowait >> lc.irq >> lc.softirq >> lc.steal >> lc.guest
      >> lc.guest_nice
    ) {
      //std::cout << std::fixed << std::setprecision(0);
      avg = 0.0; // Reset the average
      sub = name.substr(0,3);
      if (sub != "cpu") { break; }
      
      // Generate the total value of this parse timings
      //total = user + nice + system + idle + iowait + irq + softirq
      //  + steal + guest + guest_nice;
        
      // DEBUG
      /*std::cout << "ROW : " << name << " " << user << " " << nice << " "
        << system << " " << idle << " " << iowait << " " << irq << " "
        << softirq << " " << steal << " " << guest << " " << guest_nice << "\n"
        << " total: " << total << "\n---\n";*/
      
      // Set the index of the processor
      if (name.length() > 3) { pindex = std::stoi(name.substr(3)); }
      else { pindex = -1; } // -1 will be used for the average
      lc.pindex = pindex;
      //std::cout << "Index for this processor will be: " << pindex << "\n";
      
      // Attach the logical processor to the hash
      rb_hash_aset(packages, INT2NUM(pindex), 
        SysCorePlusPlus::u_method_syscore_map_lcore(lc));
      
      // See if there was a previous entry with this key
      // Change this to use the pindex, later...
      /*auto old = stat_data.find(pindex);
      if (old != stat_data.end()) {
        std::cout << std::fixed << std::setprecision(2);
        auto odat = old->second;
        long otot = std::get<1>(odat);
        long oidl = std::get<2>(odat);
        long deltot = total - otot;
        long delidl = idle - oidl;
        //std::cout << "(total, idle, deltot, delidl) = "
          << total << ", " << idle << ", " << deltot << ", "
          << delidl << "\n";
        avg = ((double(deltot) - double(delidl)) / double(deltot)) * 100;
        //std::cout << "Average use: " << avg << "%\n";
      }*/
      //stat_data.emplace(pindex, std::make_tuple(name, total, idle, avg));
      count++;
    }
    fd.close(); // Clean up file descriptor
    //std::cout << "Total lines with core data in proc file: " << count << "\n";
    //end_of_cores = count;
    return packages;
  } // End processor usage stat method
} // End main C++ segment namespace

// Core Ruby methods in C
extern "C" {
  // --------- //
  // Miscellaneous access methods
  // --------- //

  // Return the user's ID
  VALUE method_misc_uid(VALUE self) { return UINT2NUM(getuid()); }

  // Returns if the current user is root or not
  VALUE method_misc_root(VALUE self) { return (getuid() == 0 ? Qtrue : Qfalse); }

  // --------- //
  // Host information access methods
  // --------- //

  /* Return data from the uname system call.
    * 
    * The nodename field was not included (currently), because it becomes redundant
    * with the gethostname() function. Using the nodename field adds in an extra
    * instance of the hostname, which, if not updated in both calls, results in 
    * inconsistent values. This has 2 potential side effects:
    * 
    * 1) The library MUST update both EVERY time (despite nodename being the only
    *      value that can generally change without a system reboot...)
    * 2) The user of the extension potentially having erroneous data
    * 
    * Will decide at a later time whether to add it back in or not, but I will
    * leave it commented out, for now.
    */
  VALUE method_host_uname(VALUE self) {
    // Initialize a sysinfo struct and populate it
    struct utsname sysinfo;
    uname(&sysinfo);
    
    // Generate a hash to return to Ruby
    VALUE hash = rb_hash_new();
    rb_hash_aset(hash, rb_id2sym(rb_intern("sysname")), rb_str_new2(sysinfo.sysname));
    //rb_hash_aset(hash, rb_id2sym(rb_intern("nodename")), rb_str_new2(sysinfo.nodename));
    rb_hash_aset(hash, rb_id2sym(rb_intern("release")), rb_str_new2(sysinfo.release));
    rb_hash_aset(hash, rb_id2sym(rb_intern("version")), rb_str_new2(sysinfo.version));
    rb_hash_aset(hash, rb_id2sym(rb_intern("machine")), rb_str_new2(sysinfo.machine));
    
    return hash;
  } // End uname

  // Return the host name
  VALUE method_host_hostname(VALUE self) {
    HOSTSTR;
    gethostname(name, MAXSTR);
    return rb_str_new2(name);
  } // End host name

  // Return the domain name
  VALUE method_host_domainname(VALUE self) {
    HOSTSTR;
    getdomainname(name, MAXSTR);
    return rb_str_new2(name);
  } // End domain name

  // --------- //
  // Base system time monitoring methods
  // --------- //

  // Return the boot time of the machine
  VALUE method_syscore_boot_time(VALUE self) {
    return INT2NUM(getbtime());
  } // End boot time method

  // Return the uptime of the machine
  VALUE method_syscore_uptime(VALUE self) {
    double upsecs, idlesecs;
    uptime(&upsecs, &idlesecs);
    
    VALUE out = rb_hash_new();
    rb_hash_aset(out, ID2SYM(rb_intern("up")), DBL2NUM(upsecs));
    rb_hash_aset(out, ID2SYM(rb_intern("idle")), DBL2NUM(idlesecs));
    
    return out;
  } // End uptime method

  // --------- //
  // Resource management methods
  // --------- //

  // --------- //
  // Memory monitoring methods
  // --------- //

  // RAM method
  VALUE method_syscore_ram(VALUE self) {
    meminfo(); // Initialize the memory info
    VALUE out = rb_hash_new(); // Initialize the storage struct
    
    // Main memory
    rb_hash_aset(out, ID2SYM(rb_intern("free")), LONG2NUM(kb_main_free));
    rb_hash_aset(out, ID2SYM(rb_intern("avail")), LONG2NUM(kb_main_available));
    rb_hash_aset(out, ID2SYM(rb_intern("cached")), LONG2NUM(kb_main_cached));
    rb_hash_aset(out, ID2SYM(rb_intern("buffers")), LONG2NUM(kb_main_buffers));
    rb_hash_aset(out, ID2SYM(rb_intern("used")), LONG2NUM(kb_main_used));
    rb_hash_aset(out, ID2SYM(rb_intern("total")), LONG2NUM(kb_main_total));
    
    return out;
  } // End RAM method

  // SWAP method
  VALUE method_syscore_swap(VALUE self) {
    meminfo(); // Initialize the memory info
    VALUE out = rb_hash_new(); // Initialize the storage struct
    
    // Swap data
    rb_hash_aset(out, ID2SYM(rb_intern("free")), LONG2NUM(kb_swap_free));
    rb_hash_aset(out, ID2SYM(rb_intern("used")), LONG2NUM(kb_swap_used));
    rb_hash_aset(out, ID2SYM(rb_intern("total")), LONG2NUM(kb_swap_total));
    
    return out;
  } // End SWAP method

  // --------- //
  // Processor monitoring methods
  // --------- //
  // Count CPU parts count
  VALUE method_syscore_cpu_count(VALUE self) {
    // Check if library is init
    CPUI_INIT;
    
    // Hash of the parts included
    VALUE out = rb_hash_new();
    
    // Attach package, cluster, core, and logical unit count
    rb_hash_aset(out, ID2SYM(rb_intern("packages")),
      INT2NUM(cpuinfo_get_packages_count()));
    rb_hash_aset(out, ID2SYM(rb_intern("clusters")),
      INT2NUM(cpuinfo_get_clusters_count()));
    rb_hash_aset(out, ID2SYM(rb_intern("cores")),
      INT2NUM(cpuinfo_get_cores_count()));
    rb_hash_aset(out, ID2SYM(rb_intern("lprocs")),
      INT2NUM(cpuinfo_get_processors_count()));
    
    // Return the count list
    return out;
  } // End CPU parts count method

  // --------- //
  // Processes and threads section
  // --------- //
  // Count the number of processes currently running
  VALUE method_syscore_procps_count(VALUE self) {
    PTABLE = openproc(0); // Fill the process table
    int cnt = 0; // Counter
    while (proc_t *cproc = readproc(PTABLE, NULL)) {
      cnt++; // Increment the counter
      freeproc(cproc); // Free the process item
    } // Find the last pointer
    closeproc(PTABLE); // Clear the process table
    return INT2NUM(cnt); // Return the counter as a Ruby type
  } // End process count
  
  // --------- //
  // End of processes and threads section
  // --------- //
  
  // --------- //
  // End of monitoring and resource section
  // --------- //

  // Init method
  void Init_syscore() {
    // Define the module
    SysCore = rb_define_module("SysCore");
    
    // CpuInfo read-only
    //rb_define_readonly_variable("$CpuInfoInit", &cpu_info_init);
    //CpuInfoInit = Qfalse; // Give it a default non-init state
    
    // Module methods
    // Extraneous / general accessors
    rb_define_module_function(SysCore, "uid", method_misc_uid, 0);
    rb_define_module_function(SysCore, "root?", method_misc_root, 0);
    
    // Time methods
    rb_define_module_function(SysCore, "boot_time", method_syscore_boot_time, 0);
    rb_define_module_function(SysCore, "btime", method_syscore_boot_time, 0);
    rb_define_module_function(SysCore, "uptime", method_syscore_uptime, 0);
    
    // Host access methods
    rb_define_module_function(SysCore, "uname", method_host_uname, 0);
    rb_define_module_function(SysCore, "hostname", method_host_hostname, 0);
    rb_define_module_function(SysCore, "domainname", method_host_domainname, 0);
    
    // CpuInfo methods
    //rb_define_module_function(SysCore, "init", method_syscore_cpuinfo_init, 0);
    //rb_define_module_function(SysCore, "deinit", method_syscore_cpuinfo_deinit, 0);
    rb_define_module_function(SysCore, "cpu_count", method_syscore_cpu_count, 0);
    
    // Other CPU methods
    // Stat the processor cores
    rb_define_module_function(SysCore, "pstat",
      SysCorePlusPlus::method_syscore_proc_stat, 0);
    
    // Memory methods
    rb_define_module_function(SysCore, "mem", method_syscore_ram, 0);
    rb_define_module_function(SysCore, "swap", method_syscore_swap, 0);
    
    // Processes
    rb_define_module_function(SysCore, "pcount", method_syscore_procps_count, 0);
    
    // De-initialize libraries
    atexit(cpuinfo_deinitialize);
  } // End init
}