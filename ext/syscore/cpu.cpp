// ext/syscore/cpu.cpp

// Ruby include
#include <ruby.h>

// Library includes
#include <cpufreq.h>
#include <cpuinfo.h>
#include <proc/procps.h>
#include <proc/readproc.h>

// Include header
#include "cpu.hpp"

// Process table global -- NOT exposed/wrapped
PROCTAB *PTABLE = 0;

// C-style part
extern "C" {
  bool cpu_info_init = false; // Initializer
  
  // Required initialization
  // Initialize the CPU info
  bool method_syscore_cpuinfo_init() {
    if (!cpu_info_init) {
      // Initialize the system.
      cpu_info_init = cpuinfo_initialize();
    }
    return cpu_info_init; // Return current state of the flag
  } // End CPU info init

  // Deinitialize the CPU info
  bool method_syscore_cpuinfo_deinit() {
    if (cpu_info_init) {
      // If the flag is initialized, run the cleanup
      cpuinfo_deinitialize();
      cpu_info_init = false; // Then set the flag to Ruby false
    }
    return cpu_info_init; // Return the flag
  } // End CPU info deinit
  // End required initialization
  
  // --------- //
  // Processor monitoring methods
  // --------- //
  // Count CPU parts count
  VALUE method_syscore_cpu_count(VALUE self) {
    // Check if library is init
    CPUI_INIT;
    
    // Hash of the parts included
    VALUE out = rb_hash_new();
    
    // Attach package, cluster, core, and logical unit count
    rb_hash_aset(out, ID2SYM(rb_intern("packages")),
      INT2NUM(cpuinfo_get_packages_count()));
    rb_hash_aset(out, ID2SYM(rb_intern("clusters")),
      INT2NUM(cpuinfo_get_clusters_count()));
    rb_hash_aset(out, ID2SYM(rb_intern("cores")),
      INT2NUM(cpuinfo_get_cores_count()));
    rb_hash_aset(out, ID2SYM(rb_intern("lprocs")),
      INT2NUM(cpuinfo_get_processors_count()));
    
    // Return the count list
    return out;
  } // End CPU parts count method

  // --------- //
  // Processes and threads section
  // --------- //
  // Count the number of processes currently running
  VALUE method_syscore_procps_count(VALUE self) {
    PTABLE = openproc(0); // Fill the process table
    int cnt = 0; // Counter
    while (proc_t *cproc = readproc(PTABLE, NULL)) {
      cnt++; // Increment the counter
      freeproc(cproc); // Free the process item
    } // Find the last pointer
    closeproc(PTABLE); // Clear the process table
    return INT2NUM(cnt); // Return the counter as a Ruby type
  } // End process count
} // End C-style part

// C++ segment
namespace SysCorePlusPlus {
  // Read from a specified file, generated by a path constructor,
  // and return the unformatted data for processing.
  std::string u_method_read_core_attrib_file(std::string fname) {
    std::ifstream fd(fname); // Open the file
    std::string attrib (
      (std::istreambuf_iterator<char>(fd)),
      (std::istreambuf_iterator<char>())
    ); // Create the attribute data
    boost::algorithm::trim(attrib); // Trim it
    fd.close(); // Close the file
    return attrib; // Return the unformatted data
  } // End core file appendment method
  
  // Attach paths to the core, for reference
  str_map_t u_method_syscore_lcore_paths(VALUE lch, std::string base_path) {
    VALUE p_hash = rb_hash_new(); // Create the hash to store the paths
    str_map_t paths; // Create a map
    
    // CPU processor base path
    std::string sys_path = CPU_BUS_PATH + base_path; // SysFS path
    paths.emplace(MK_SSP("sysfs", sys_path));
    
    // Topologies
    std::string topo = sys_path + "/topology";
    paths.emplace(MK_SSP("topology", topo));
    
    // Frequencies
    std::string freq = sys_path + "/cpufreq";
    paths.emplace(MK_SSP("frequency", freq));
    
    // Attach each path to the core map
    for (auto itr = paths.begin(); itr != paths.end(); itr++) {
      rb_hash_aset(p_hash, ID2SYM(rb_intern(itr->first.c_str())),
        rb_str_new2(itr->second.c_str())); }
    
    // Attach the path hash to the core
    rb_hash_aset(lch, ID2SYM(rb_intern("paths")), p_hash);
    return paths;
  } // End core path appendment method
  
  // Attach online status
  void u_method_syscore_lcore_online(VALUE lch, 
    const lcore_t *lcr, str_map_t paths) {
    auto itr_idx = paths.find(std::string("sysfs"));
    if (itr_idx != paths.end()) {
      rb_hash_aset(lch, ID2SYM(rb_intern("online")),
        INT2NUM(
          atoi(u_method_read_core_attrib_file(
            itr_idx->second + "/online").c_str()))); }
  } // End online status
  
  // Attach package ID to the core
  void u_method_syscore_lcore_package(VALUE lch, 
    const lcore_t *lcr, str_map_t paths) {
    auto itr_idx = paths.find(std::string("sysfs"));
    if (itr_idx != paths.end()) {
      // Get the package / socket ID
      uint pkg_id = atoi(u_method_read_core_attrib_file(
        itr_idx->second + "/physical_package_id").c_str());
      
      // Load in the package object
      CPUI_INIT; // Shorthand initializer
      const cpuinfo_package *pkg = cpuinfo_get_package(pkg_id); // Package object
      
      // Store the name of the package from above
      rb_hash_aset(lch, ID2SYM(rb_intern("name")), rb_str_new2(pkg->name));
      
      // Store the package ID number
      rb_hash_aset(lch, ID2SYM(rb_intern("sock_num")), INT2NUM(pkg_id));
    }
  } // End package ID appendment
  
  // Attach core ID to the core
  void u_method_syscore_lcore_core_num(VALUE lch, 
    const lcore_t *lcr, str_map_t paths) {
    auto itr_idx = paths.find(std::string("topology"));
    if (itr_idx != paths.end()) {
      rb_hash_aset(lch, ID2SYM(rb_intern("core_num")),
        INT2NUM(
          atoi(u_method_read_core_attrib_file(
            itr_idx->second + "/core_id").c_str()))); }
  } // End core ID appendment
  
  // Attach frequencies to the core
  void u_method_syscore_lcore_core_freq(VALUE lch, 
    const lcore_t *lcr, str_map_t paths) {
    auto itr_idx = paths.find(std::string("frequency"));
    if (itr_idx != paths.end()) {
      rb_hash_aset(lch, ID2SYM(rb_intern("freq_driver")),
        rb_str_new2(u_method_read_core_attrib_file(
          itr_idx->second + "/scaling_driver").c_str()));
      rb_hash_aset(lch, ID2SYM(rb_intern("freq_governor")),
        rb_str_new2(u_method_read_core_attrib_file(
          itr_idx->second + "/scaling_governor").c_str()));
      rb_hash_aset(lch, ID2SYM(rb_intern("freq_current")),
        INT2NUM(atoi(u_method_read_core_attrib_file(
          itr_idx->second + "/scaling_cur_freq").c_str())));
      rb_hash_aset(lch, ID2SYM(rb_intern("freq_max")),
        INT2NUM(atoi(u_method_read_core_attrib_file(
          itr_idx->second + "/scaling_max_freq").c_str())));
      rb_hash_aset(lch, ID2SYM(rb_intern("freq_min")),
        INT2NUM(atoi(u_method_read_core_attrib_file(
          itr_idx->second + "/scaling_min_freq").c_str())));
    } // End frequency attribute readers
  } // End frequencies appendment
  
  // Attach governor options to the core
  void u_method_syscore_lcore_core_govs(VALUE lch, 
    const lcore_t *lcr, str_map_t paths) {
    auto itr_idx = paths.find(std::string("frequency"));
    if (itr_idx != paths.end()) {
      // Optimizations
      std::ios::sync_with_stdio(false);
      std::cin.tie(NULL);
      std::cout.tie(NULL);
      
      uint ctr = 0; // Counter
      VALUE govs = rb_ary_new(); // New Ruby array of governors
      
      // Raw output
      std::string govs_raw = u_method_read_core_attrib_file(
        itr_idx->second + "/scaling_available_governors");
      
      // List of governors
      std::stringstream govs_split(govs_raw);
      
      std::string item; // Item buffer
      std::ifstream fd; // File descriptor
      
      // Loop through all the words
      while (std::getline(govs_split, item, ' ')) {
        boost::algorithm::trim(item); // Trim it
        rb_ary_store(govs, ctr, rb_str_new2(item.c_str())); // Store it
        ctr++; // Increment the counter
      } // End word loop
      
      // Add the array of governors to the hash
      rb_hash_aset(lch, ID2SYM(rb_intern("governors")), govs);
    } // End attachment of governors
  } // End governors appendment
  
  // Attach informational data to the core
  void u_method_syscore_lcore_info(VALUE lch, const lcore_t *lcr, str_map_t paths) {
    VALUE dev = rb_hash_new(); // Create device info
    VALUE freq = rb_hash_new(); // Create frequency info
    
    // Attach data to device topology hash
    u_method_syscore_lcore_package(dev, lcr, paths); // Socket
    u_method_syscore_lcore_core_num(dev, lcr, paths); // Physical core
    // Logical processor number
    rb_hash_aset(dev, ID2SYM(rb_intern("proc_num")), INT2NUM(lcr->pindex));
    u_method_syscore_lcore_online(dev, lcr, paths); // Whether online
    
    // Attach data to the frequency hash
    u_method_syscore_lcore_core_freq(freq, lcr, paths); // Frequencies
    u_method_syscore_lcore_core_govs(freq, lcr, paths); // Governors
    
    // Attach the device topology to the processor
    rb_hash_aset(lch, ID2SYM(rb_intern("device")), dev);
    // Attach the frequency data to the processor
    rb_hash_aset(lch, ID2SYM(rb_intern("frequencies")), freq);
  } // End informational appendment

  // Read in a single logical processor and map it
  // Not exported, because takes non-Ruby values
  // Will return a raw hash to be wrapped Ruby-side
  VALUE u_method_syscore_map_lcore(lcore_t lcr) {
    // New CPU hash
    VALUE lch = rb_hash_new();
    
    // Path identifier
    // Add the paths to use for this processor
    str_map_t paths = u_method_syscore_lcore_paths(lch, lcr.path);
    
    // Usage stats
    rb_hash_aset(lch, ID2SYM(rb_intern("user")), DBL2NUM(lcr.user));
    rb_hash_aset(lch, ID2SYM(rb_intern("nice")), DBL2NUM(lcr.nice));
    rb_hash_aset(lch, ID2SYM(rb_intern("system")), DBL2NUM(lcr.system));
    rb_hash_aset(lch, ID2SYM(rb_intern("idle")), DBL2NUM(lcr.idle));
    rb_hash_aset(lch, ID2SYM(rb_intern("iowait")), DBL2NUM(lcr.iowait));
    rb_hash_aset(lch, ID2SYM(rb_intern("irq")), DBL2NUM(lcr.irq));
    rb_hash_aset(lch, ID2SYM(rb_intern("softirq")), DBL2NUM(lcr.softirq));
    rb_hash_aset(lch, ID2SYM(rb_intern("steal")), DBL2NUM(lcr.steal));
    rb_hash_aset(lch, ID2SYM(rb_intern("guest")), DBL2NUM(lcr.guest));
    rb_hash_aset(lch, ID2SYM(rb_intern("guest_nice")), DBL2NUM(lcr.guest_nice));
    
    // Add additional information
    u_method_syscore_lcore_info(lch, &lcr, paths);
    
    // Return the mapped CPU hash
    return lch;
  } // End CPU logical core wrapper

  // Processor usage stat method
  VALUE method_syscore_proc_stat(VALUE self) {
    // Optimizations
    std::ios::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    
    // File
    std::ifstream fd;
    
    // Data components
    std::string sub;
    double total, avg;
    int pindex;
    
    // Logical processor core
    SysCorePlusPlus::lcore_t lc;
    
    // Counter
    int count = 0;
    
    // Create hash to hold the logical processors,
    // mapped to the package, with sister elements of
    // cluster and core data.
    VALUE packages = rb_hash_new();
    
    // Stream read loop
    fd.open(PROC_FILE);
    while (fd >> lc.path >> lc.user >> lc.nice >> lc.system >> lc.idle
      >> lc.iowait >> lc.irq >> lc.softirq >> lc.steal >> lc.guest
      >> lc.guest_nice
    ) {
      avg = 0.0; // Reset the average
      sub = lc.path.substr(0,3);
      if (sub != "cpu") { break; }
      
      // Set the index of the processor
      if (lc.path.length() > 3) { pindex = std::stoi(lc.path.substr(3)); }
      else { pindex = -1; } // -1 will be used for the average
      lc.pindex = pindex;
      //std::cout << "Index for this processor will be: " << pindex << "\n";
      
      // Attach the logical processor to the hash
      rb_hash_aset(packages, INT2NUM(pindex), 
        SysCorePlusPlus::u_method_syscore_map_lcore(lc));
      
      // See if there was a previous entry with this key
      // Change this to use the pindex, later...
      /*auto old = stat_data.find(pindex);
      if (old != stat_data.end()) {
        std::cout << std::fixed << std::setprecision(2);
        auto odat = old->second;
        long otot = std::get<1>(odat);
        long oidl = std::get<2>(odat);
        long deltot = total - otot;
        long delidl = idle - oidl;
        //std::cout << "(total, idle, deltot, delidl) = "
          << total << ", " << idle << ", " << deltot << ", "
          << delidl << "\n";
        avg = ((double(deltot) - double(delidl)) / double(deltot)) * 100;
        //std::cout << "Average use: " << avg << "%\n";
      }*/
      //stat_data.emplace(pindex, std::make_tuple(name, total, idle, avg));
      count++;
    }
    fd.close(); // Clean up file descriptor
    return packages;
  } // End processor usage stat method
} // End main C++ segment namespace